# 1341. Movie Rating

## 📝 Problem Statement

### Table:`Movies`


| Column Name   | Type    |
|---------------|---------|
| movie_id      | int     |
| title         | varchar |

 - movie_id is the primary key (column with unique values) for this table.
 - title is the name of the movie.
 

### Table: `Users`


| Column Name   | Type    |
|---------------|---------|
| user_id       | int     |
| name          | varchar |

 - user_id is the primary key (column with unique values) for this table.
 - The column 'name' has unique values.

### Table: `MovieRating`


| Column Name   | Type    |
|---------------|---------|
| movie_id      | int     |
| user_id       | int     |
| rating        | int     |
| created_at    | date    |

 - (movie_id, user_id) is the primary key (column with unique values) for this table.
 - This table contains the rating of a movie by a user in their review.
created_at is the user's review date. 
 

Write a solution to:

 - Find the name of the user who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name.
 - Find the movie name with the highest average rating in February 2020. In case of a tie, return the lexicographically smaller movie name.

### Example Input:

Input: 
Customer table:

| customer_id | name         | visited_on   | amount      |
|-------------|--------------|--------------|-------------|
| 1           | Jhon         | 2019-01-01   | 100         |
| 2           | Daniel       | 2019-01-02   | 110         |
| 3           | Jade         | 2019-01-03   | 120         |
| 4           | Khaled       | 2019-01-04   | 130         |
| 5           | Winston      | 2019-01-05   | 110         | 
| 6           | Elvis        | 2019-01-06   | 140         | 
| 7           | Anna         | 2019-01-07   | 150         |
| 8           | Maria        | 2019-01-08   | 80          |
| 9           | Jaze         | 2019-01-09   | 110         | 
| 1           | Jhon         | 2019-01-10   | 130         | 
| 3           | Jade         | 2019-01-10   | 150         | 

Output: 

| visited_on   | amount       | average_amount |
|--------------|--------------|----------------|
| 2019-01-07   | 860          | 122.86         |
| 2019-01-08   | 840          | 120            |
| 2019-01-09   | 840          | 120            |
| 2019-01-10   | 1000         | 142.86         |

Explanation: 
 - 1st moving average from 2019-01-01 to 2019-01-07 has an average_amount of (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86
 - 2nd moving average from 2019-01-02 to 2019-01-08 has an average_amount of (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120
 - 3rd moving average from 2019-01-03 to 2019-01-09 has an average_amount of (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120
 - 4th moving average from 2019-01-04 to 2019-01-10 has an average_amount of (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86
   
## 💡 SQL Solution

```sql

WITH
  Dates AS (
    SELECT DISTINCT visited_on
    FROM Customer
    WHERE visited_on >= (
      SELECT DATE_ADD(MIN(visited_on), INTERVAL 6 DAY)
      FROM Customer
    )
  )
SELECT
  Dates.visited_on,
  SUM(Customer.amount) AS amount,
  ROUND(SUM(Customer.amount) / 7, 2) AS average_amount
FROM Dates
LEFT JOIN Customer
  ON (DATEDIFF(Dates.visited_on, Customer.visited_on) BETWEEN 0 AND 6)
GROUP BY 1;

# Write your MySQL query statement below
    
(
    SELECT name AS results
    FROM
        Users
        JOIN MovieRating USING (user_id)
    GROUP BY user_id
    ORDER BY COUNT(1) DESC, name
    LIMIT 1
)
UNION ALL
(
    SELECT title
    FROM
        MovieRating
        JOIN Movies USING (movie_id)
    WHERE DATE_FORMAT(created_at, '%Y-%m') = '2020-02'
    GROUP BY movie_id
    ORDER BY AVG(rating) DESC, title
    LIMIT 1
);
